# lagou-e-task-01-02
一、

执行结果为：10。

原因：for循环执行时，i的值从0开始依次被赋值，最终变成了10，console.log(i)这里的i是全局对象VO里的i，a[6]（）代码执行时，创建了一个对象，在当前作用域下没有i这个值，沿着作用域链向上寻找，上一级作用域是函数创建时的作用域，也就是全局作用域，在全局作用域下找到了i，此时i的值是10，则打印10

二、

执行结果：会报错tmp 未定义

原因：console.log(tmp)执行时，后面用let tmp声明了这个变量，创建了一个块级作用域，外部无法访问，又因为let声明的变量必须先声明后使用，所以会报tmp 未定义的错误。

三、

var newarr = Array.from(new Set(arr))

Math.min(...newarr)

四、

var：变量可以先使用后声明，只是在开始值是undifined，也就是变量提升，可读写。

let：变量必须先声明后使用，否则报错。可读写，let声明变量后会创建一层块级作用域，不受外部影响。

const：变量是恒量，也可以说是常量，只能读，不能写，声明变量时必须直接赋值。

五、

输出结果：10

obj.fn（）执行时，调用的是setTimeout,这里是箭头函数，箭头函数没有this，那么this.a中的this指向上一级，也就是obj，而obj的this是window，所以，调用的是window下的a，所以输出结果是10

六、

Symbol类型，可以创建一个独一无二的值。主要是给对象添加独一无二的属性名来作为私有属性。

七、

浅拷贝：把一个对象进行复制时，复制的是这个对象的地址，他们指针指向的是同一片内存空间

深拷贝：把一个对象进行复制时，复制的是对象的内容，并为新对象的内容开辟一个自己的空间，两个对象的地址不一样，分别指向各自的堆内存。

八、

js是弱类型语言，ts是强类型语言，ts是基于js基础之上的语言，ts是js的超集，可以再ts中使用任何原生js语法；ts在编译时就可以发现类型错误，js只有在运行时才能发现，ts最终要编译成js再运行。

九、

优点：ts是一个强类型的语言，解决了js类型系统的不足，不允许任意类型的隐士转换，提高了代码的可靠程度。

（1）错误能更早暴露，在编译阶段就会把类型异常暴露出来，不用等到运行阶段再查找错误；

（2）ts更加智能，编码也会更加准确，在开发阶段，ts的类型比较准确，方便编辑器的智能提示，提高开发效率；

（3）重构更牢靠，当修改一个地方的时候，与其关联的其它地方就会报错，方便我们去重构；

（4）减少不必要的类型判断。

缺点：

学习ts成本较高，需要理解一些抽象的概念，如接口、泛型、等一些类似于后台java语言的概念。

十、

引用计数的原理：给对象设置一个引用数值，对象每被引用一次，数值+1，进行gc时，垃圾回收器会立即找到引用数值为0的进行垃圾释放回收。

优点：可以立即回收对象，大限度减少程序的暂停

缺点：无法回收寻魂引用的对象；时间开销大，要给每个对象维护一个引用数值，对数值进行修改，这样对象一多，修改就会浪费更多时间。

十一、

标记整理算法：在GC时，标记整理先给可达对象进行标记，标记完成后，把对象进行排序，在地址上产生连续的空间，然后再清除非活动对象。

十二、

v8新生代存储区垃圾回收：新生代回收采用标记整理和复制算法，在新生代内存中分为form和to两个等大的空间，to空间空闲，from中存储活动对象，先在form中把活动对象进行标记，然后移动对象，产生连续地址，gc时把活动对象从from拷贝到to，from和to交换空间完成释放。当然从from到to 的过程中，可能会出现晋升的情况，也就是经过一轮GC还存活的对象，说明在老生代也有对它地址的引用，这个对象会移动到老生代，当to的使用率超过25%也会晋升。

十三、增量标记：在程序执行时，暂停一下，去把所有直接可达的对象进行标记，然后继续执行程序，然后再去把间接可达的对象进行标记，再继续执行程序，依次这样标记和程序执行交替执行，完成垃圾清除后再执行程序。

